# Modules

The user creates a *module* and adds various *module objects* to it. Examples of such module objects are type factories and functions.

Each module object has a *name* (a symbol). Objects added to the module can be looked up using this name. Each kind of module object has its own namespace.

# Module objects

## Type factory

- `name`
- `constructor`: a Scheme procedure used to create a type of this factory
- `parents`: a list of type factories, used to establish a type hierarchy

A *type expression* is either a symbol or a list starting with a symbol. In both cases, the symbol serves as the *type name*. If the type expression is a list and it has elements after the initial type name, those elements become *type arguments*. Type arguments must be numbers or type expressions.

A type expression is *resolved* by looking up the corresponding type factory by name, then applying the constructor of this factory to the resolved type arguments (if any). The resulting *type* is cached in the type factory so that future lookups of the same type expression result in the same type.

Every object referred to by the program has an associated type. In the source code these types are denoted by type expressions. Type expressions are resolved into types when the program gets compiled.

Types "remember" which type factory they are coming from. With the help of the `parents` attribute, type factories - and thus types themselves - can be organized into a type hierarchy. The parents of type factory `tf` are those type factories which can be found in the `parents` list of `tf`. The ancestors of type factory `tf` are those type factories which are either parents of `tf` or ancestors of a parent of `tf`.

If `t1` and `t2` are types, `(isa? t1 t2)` returns #t if all operations supported by an object of type `t2` are also supported by an object of type `t1`. The isa? function works as follows:

1. Let `(tf t)` denote the type factory of type `t`.
2. Let `tf1` be `(tf t1)` and `tf2` be `(tf t2)`.
3. If `tf2` is an ancestor of `tf1`, return #t
4. If `tf2` does not equal `tf1`, return #f
5. If there is a specialization of isa? for the `tf1`==`tf2` case, apply it to `t1` and `t2`, return the result
6. return #f

## Function

- `name`
- `methods`: a hash of `type expression` -> (`method` | `hash`) pairs

A function is looked up by name and then by argument types. After the name-based lookup succeeds, we look at the 

### Methods

- `name`
- `ret`: return type
- `args`: arguments (names and types)
- `include`: the include file which declares this function
- `body`: a list of forms
- `compile`: a Scheme procedure which compiles calls to this function

If a function is externally declared (typically in a C include file) then `include` is set to the name of the include file. If the value is a string, it will be generated into the C code as `#include "value"`. If it's a list containing a single string, the C code will be `#include <value>`.

If the function is both declared and defined, either `body` or `compile` should be set. `Body` is a list of forms which should be compiled as the body of the function. `Compile` points to a Scheme procedure which compiles calls made to this function. By default, this is a proc which generates a C call to the corresponding function.
